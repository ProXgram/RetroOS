#include "graphics.h"
#include <stddef.h>
#include <stdbool.h>
#include "system.h"

static uint32_t* g_framebuffer = NULL;
static uint32_t g_width = 0;
static uint32_t g_height = 0;
static uint32_t g_pitch = 0;

// Minimal 8x8 Bitmap Font (CP437-ish subset)
// 1 = Pixel On, 0 = Pixel Off
static const uint8_t FONT_8X8[128][8] = {
    {0,0,0,0,0,0,0,0}, // 0x00 (Null)
    // ... We need a visible font. Let's define basic ASCII characters conceptually
    // For brevity in this response, I will generate a block cursor for undefined chars
    // and implement A-Z, 0-9, and basic symbols.
    [0x20] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // Space
    [0x21] = {0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00}, // !
    [0x23] = {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00}, // #
    [0x2D] = {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // -
    [0x2E] = {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, // .
    [0x30] = {0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00}, // 0
    [0x31] = {0x18,0x18,0x38,0x18,0x18,0x18,0x7E,0x00}, // 1
    [0x32] = {0x3C,0x66,0x06,0x0C,0x30,0x60,0x7E,0x00}, // 2
    [0x33] = {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00}, // 3
    [0x34] = {0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x00}, // 4
    [0x35] = {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00}, // 5
    [0x36] = {0x3C,0x60,0x7C,0x66,0x66,0x66,0x3C,0x00}, // 6
    [0x37] = {0x7E,0x06,0x06,0x0C,0x18,0x18,0x18,0x00}, // 7
    [0x38] = {0x3C,0x66,0x3C,0x66,0x66,0x66,0x3C,0x00}, // 8
    [0x39] = {0x3C,0x66,0x66,0x66,0x3E,0x06,0x3C,0x00}, // 9
    [0x3A] = {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00}, // :
    [0x3D] = {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00}, // =
    [0x41] = {0x3C,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // A
    [0x42] = {0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00}, // B
    [0x43] = {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00}, // C
    [0x44] = {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00}, // D
    [0x45] = {0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00}, // E
    [0x46] = {0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00}, // F
    [0x47] = {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00}, // G
    [0x48] = {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // H
    [0x49] = {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // I
    [0x4A] = {0x1E,0x0C,0x0C,0x0C,0x0C,0xCC,0x78,0x00}, // J
    [0x4B] = {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00}, // K
    [0x4C] = {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00}, // L
    [0x4D] = {0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00}, // M
    [0x4E] = {0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00}, // N
    [0x4F] = {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // O
    [0x50] = {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00}, // P
    [0x51] = {0x3C,0x66,0x66,0x66,0x66,0x3C,0x0E,0x00}, // Q
    [0x52] = {0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x00}, // R
    [0x53] = {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00}, // S
    [0x54] = {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00}, // T
    [0x55] = {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // U
    [0x56] = {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00}, // V
    [0x57] = {0x63,0x63,0x6B,0x7F,0x7F,0x77,0x63,0x00}, // W
    [0x58] = {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00}, // X
    [0x59] = {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00}, // Y
    [0x5A] = {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00}, // Z
    [0x61] = {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00}, // a
    [0x62] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00}, // b
    [0x63] = {0x00,0x00,0x3C,0x60,0x60,0x60,0x3C,0x00}, // c
    [0x64] = {0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00}, // d
    [0x65] = {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00}, // e
    [0x66] = {0x1C,0x20,0x78,0x20,0x20,0x20,0x20,0x00}, // f
    [0x67] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C}, // g
    [0x68] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00}, // h
    [0x69] = {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // i
    [0x6A] = {0x06,0x00,0x06,0x06,0x06,0x06,0x06,0x3C}, // j
    [0x6B] = {0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00}, // k
    [0x6C] = {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // l
    [0x6D] = {0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00}, // m
    [0x6E] = {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00}, // n
    [0x6F] = {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00}, // o
    [0x70] = {0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60}, // p
    [0x71] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06}, // q
    [0x72] = {0x00,0x00,0x5C,0x66,0x60,0x60,0x60,0x00}, // r
    [0x73] = {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00}, // s
    [0x74] = {0x20,0x20,0x78,0x20,0x20,0x20,0x1C,0x00}, // t
    [0x75] = {0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00}, // u
    [0x76] = {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00}, // v
    [0x77] = {0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00}, // w
    [0x78] = {0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00}, // x
    [0x79] = {0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C}, // y
    [0x7A] = {0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00}, // z
};

void graphics_init(void) {
    const struct BootInfo* info = system_boot_info();
    g_framebuffer = (uint32_t*)info->framebuffer;
    g_width = info->width;
    g_height = info->height;
    g_pitch = info->pitch;
}

void graphics_put_pixel(int x, int y, uint32_t color) {
    if (x < 0 || (uint32_t)x >= g_width || y < 0 || (uint32_t)y >= g_height) return;
    
    // Pitch is in bytes, but g_framebuffer is uint32_t* (4 bytes)
    // So index = (y * (pitch / 4)) + x
    size_t index = y * (g_pitch / 4) + x;
    g_framebuffer[index] = color;
}

void graphics_fill_rect(int x, int y, int w, int h, uint32_t color) {
    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            graphics_put_pixel(x + i, y + j, color);
        }
    }
}

void graphics_draw_char(int x, int y, char c, uint32_t fg, uint32_t bg) {
    // Fallback for undefined chars (draw box)
    const uint8_t* glyph = FONT_8X8[0x20]; 
    
    // Cast to unsigned char to avoid signed comparison warnings and errors
    unsigned char uc = (unsigned char)c;
    if (uc < 128) {
        glyph = FONT_8X8[uc];
    } else {
        // Unknown char
        glyph = FONT_8X8['?'];
    }

    for (int row = 0; row < 8; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < 8; col++) {
            // Font is usually MSB left. bit 7 = pixel 0
            bool on = (bits >> (7 - col)) & 1;
            if (on) {
                graphics_put_pixel(x + col, y + row, fg);
            } else {
                // Draw background pixel only if not transparent
                // (Here we assume opaque text block)
                graphics_put_pixel(x + col, y + row, bg);
            }
        }
    }
}

void graphics_draw_char_scaled(int x, int y, char c, uint32_t fg, uint32_t bg, int scale) {
    if (scale < 1) scale = 1;
    
    unsigned char uc = (unsigned char)c;
    const uint8_t* glyph = (uc < 128) ? FONT_8X8[uc] : FONT_8X8['?'];

    for (int row = 0; row < 8; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < 8; col++) {
            bool on = (bits >> (7 - col)) & 1;
            uint32_t color = on ? fg : bg;
            
            // Only draw if it's foreground, OR if background is opaque (assuming bg != 0 for now)
            // But usually we want to draw the BG block too for blocky feel.
            graphics_fill_rect(x + (col * scale), y + (row * scale), scale, scale, color);
        }
    }
}

void graphics_draw_string_scaled(int x, int y, const char* str, uint32_t fg, uint32_t bg, int scale) {
    int cur_x = x;
    while (*str) {
        graphics_draw_char_scaled(cur_x, y, *str, fg, bg, scale);
        cur_x += 8 * scale;
        str++;
    }
}

uint32_t graphics_get_width(void) { return g_width; }
uint32_t graphics_get_height(void) { return g_height; }
