#include "graphics.h"
#include <stddef.h>
#include <stdbool.h>
#include "system.h"
#include "syslog.h"

// Hardcoded location for the backbuffer (4MB mark)
// This is safe because:
// 1. Kernel is loaded at 1MB and limited to <2MB by linker script
// 2. Bootloader stack top is 0x3FF000 (just below 4MB)
// 3. First 1GB is identity mapped
#define BACK_BUFFER_ADDR 0x00400000

static uint32_t* g_framebuffer = NULL;
static uint32_t* g_draw_buffer = NULL;
static uint32_t* g_back_buffer = (uint32_t*)BACK_BUFFER_ADDR;
static bool g_double_buffered = false;

static uint32_t g_width = 0;
static uint32_t g_height = 0;
static uint32_t g_pitch = 0;

// Minimal 8x8 Bitmap Font (CP437-ish subset)
// 1 = Pixel On, 0 = Pixel Off
static const uint8_t FONT_8X8[128][8] = {
    {0,0,0,0,0,0,0,0}, // 0x00 (Null)
    [0x20] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // Space
    [0x21] = {0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00}, // !
    [0x23] = {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00}, // #
    [0x2D] = {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // -
    [0x2E] = {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, // .
    [0x30] = {0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00}, // 0
    [0x31] = {0x18,0x18,0x38,0x18,0x18,0x18,0x7E,0x00}, // 1
    [0x32] = {0x3C,0x66,0x06,0x0C,0x30,0x60,0x7E,0x00}, // 2
    [0x33] = {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00}, // 3
    [0x34] = {0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x00}, // 4
    [0x35] = {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00}, // 5
    [0x36] = {0x3C,0x60,0x7C,0x66,0x66,0x66,0x3C,0x00}, // 6
    [0x37] = {0x7E,0x06,0x06,0x0C,0x18,0x18,0x18,0x00}, // 7
    [0x38] = {0x3C,0x66,0x3C,0x66,0x66,0x66,0x3C,0x00}, // 8
    [0x39] = {0x3C,0x66,0x66,0x66,0x3E,0x06,0x3C,0x00}, // 9
    [0x3A] = {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00}, // :
    [0x3D] = {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00}, // =
    [0x41] = {0x3C,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // A
    [0x42] = {0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00}, // B
    [0x43] = {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00}, // C
    [0x44] = {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00}, // D
    [0x45] = {0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00}, // E
    [0x46] = {0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00}, // F
    [0x47] = {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00}, // G
    [0x48] = {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // H
    [0x49] = {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // I
    [0x4A] = {0x1E,0x0C,0x0C,0x0C,0x0C,0xCC,0x78,0x00}, // J
    [0x4B] = {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00}, // K
    [0x4C] = {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00}, // L
    [0x4D] = {0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00}, // M
    [0x4E] = {0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00}, // N
    [0x4F] = {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // O
    [0x50] = {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00}, // P
    [0x51] = {0x3C,0x66,0x66,0x66,0x66,0x3C,0x0E,0x00}, // Q
    [0x52] = {0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x00}, // R
    [0x53] = {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00}, // S
    [0x54] = {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00}, // T
    [0x55] = {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // U
    [0x56] = {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00}, // V
    [0x57] = {0x63,0x63,0x6B,0x7F,0x7F,0x77,0x63,0x00}, // W
    [0x58] = {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00}, // X
    [0x59] = {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00}, // Y
    [0x5A] = {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00}, // Z
    [0x61] = {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00}, // a
    [0x62] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00}, // b
    [0x63] = {0x00,0x00,0x3C,0x60,0x60,0x60,0x3C,0x00}, // c
    [0x64] = {0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00}, // d
    [0x65] = {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00}, // e
    [0x66] = {0x1C,0x20,0x78,0x20,0x20,0x20,0x20,0x00}, // f
    [0x67] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C}, // g
    [0x68] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00}, // h
    [0x69] = {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // i
    [0x6A] = {0x06,0x00,0x06,0x06,0x06,0x06,0x06,0x3C}, // j
    [0x6B] = {0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00}, // k
    [0x6C] = {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // l
    [0x6D] = {0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00}, // m
    [0x6E] = {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00}, // n
    [0x6F] = {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00}, // o
    [0x70] = {0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60}, // p
    [0x71] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06}, // q
    [0x72] = {0x00,0x00,0x5C,0x66,0x60,0x60,0x60,0x00}, // r
    [0x73] = {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00}, // s
    [0x74] = {0x20,0x20,0x78,0x20,0x20,0x20,0x1C,0x00}, // t
    [0x75] = {0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00}, // u
    [0x76] = {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00}, // v
    [0x77] = {0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00}, // w
    [0x78] = {0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00}, // x
    [0x79] = {0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C}, // y
    [0x7A] = {0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00}, // z
};

void graphics_init(void) {
    const struct BootInfo* info = system_boot_info();
    g_framebuffer = (uint32_t*)info->framebuffer;
    g_width = info->width;
    g_height = info->height;
    g_pitch = info->pitch;
    
    // Default to direct drawing
    g_draw_buffer = g_framebuffer;
    g_double_buffered = false;
}

void graphics_enable_double_buffer(void) {
    g_draw_buffer = g_back_buffer;
    g_double_buffered = true;
    syslog_write("Graphics: Double buffering enabled");
}

void graphics_disable_double_buffer(void) {
    g_draw_buffer = g_framebuffer;
    g_double_buffered = false;
}

void graphics_swap_buffer(void) {
    if (!g_double_buffered) return;

    // Copy back buffer to front buffer
    // Pitch is in bytes. g_framebuffer is uint32* (4 bytes).
    // The safest way is row by row.
    
    // Convert pitch to uint32 count (assuming 32bpp)
    uint32_t stride = g_pitch / 4;
    
    uint32_t* src = g_back_buffer;
    uint32_t* dest = g_framebuffer;
    
    // We assume width matches stride for the back buffer, but front buffer uses pitch.
    // Actually, let's treat back buffer as having same stride as front for simplicity,
    // effectively a direct memory copy if continuous.
    
    // Note: To be safe, we iterate pixels.
    size_t total_pixels = g_height * stride;
    
    for (size_t i = 0; i < total_pixels; i++) {
        dest[i] = src[i];
    }
}

void graphics_put_pixel(int x, int y, uint32_t color) {
    if (x < 0 || (uint32_t)x >= g_width || y < 0 || (uint32_t)y >= g_height) return;
    
    // Pitch is in bytes, but g_draw_buffer is uint32_t* (4 bytes)
    // So index = (y * (pitch / 4)) + x
    size_t index = y * (g_pitch / 4) + x;
    g_draw_buffer[index] = color;
}

void graphics_fill_rect(int x, int y, int w, int h, uint32_t color) {
    // Optimization: Horizontal line filling
    int end_x = x + w;
    int end_y = y + h;
    
    // Clipping
    if (x < 0) x = 0;
    if (y < 0) y = 0;
    if (end_x > (int)g_width) end_x = g_width;
    if (end_y > (int)g_height) end_y = g_height;
    
    uint32_t stride = g_pitch / 4;
    
    for (int j = y; j < end_y; j++) {
        uint32_t* row = &g_draw_buffer[j * stride];
        for (int i = x; i < end_x; i++) {
            row[i] = color;
        }
    }
}

void graphics_draw_char(int x, int y, char c, uint32_t fg, uint32_t bg) {
    // Fallback for undefined chars (draw box)
    const uint8_t* glyph = FONT_8X8[0x20]; 
    
    // Cast to unsigned char to avoid signed comparison warnings and errors
    unsigned char uc = (unsigned char)c;
    if (uc < 128) {
        glyph = FONT_8X8[uc];
    } else {
        // Unknown char
        glyph = FONT_8X8['?'];
    }

    for (int row = 0; row < 8; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < 8; col++) {
            // Font is usually MSB left. bit 7 = pixel 0
            bool on = (bits >> (7 - col)) & 1;
            if (on) {
                graphics_put_pixel(x + col, y + row, fg);
            } else {
                // Draw background pixel only if not transparent
                // (Here we assume opaque text block)
                graphics_put_pixel(x + col, y + row, bg);
            }
        }
    }
}

void graphics_draw_char_scaled(int x, int y, char c, uint32_t fg, uint32_t bg, int scale) {
    if (scale < 1) scale = 1;
    
    unsigned char uc = (unsigned char)c;
    const uint8_t* glyph = (uc < 128) ? FONT_8X8[uc] : FONT_8X8['?'];

    for (int row = 0; row < 8; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < 8; col++) {
            bool on = (bits >> (7 - col)) & 1;
            uint32_t color = on ? fg : bg;
            
            // Only draw if it's foreground, OR if background is opaque (assuming bg != 0 for now)
            // But usually we want to draw the BG block too for blocky feel.
            graphics_fill_rect(x + (col * scale), y + (row * scale), scale, scale, color);
        }
    }
}

void graphics_draw_string_scaled(int x, int y, const char* str, uint32_t fg, uint32_t bg, int scale) {
    int cur_x = x;
    while (*str) {
        graphics_draw_char_scaled(cur_x, y, *str, fg, bg, scale);
        cur_x += 8 * scale;
        str++;
    }
}

uint32_t graphics_get_width(void) { return g_width; }
uint32_t graphics_get_height(void) { return g_height; }
